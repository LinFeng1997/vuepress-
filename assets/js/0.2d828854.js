(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{156:function(e,l,i){"use strict";i.r(l);var a=i(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,l=e.$createElement,i=e._self._c||l;return i("div",{staticClass:"content"},[i("h2",{attrs:{id:"webpack-管理（10分钟）"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#webpack-管理（10分钟）","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack 管理（10分钟）")]),i("p",[e._v("webpack-chain 动态生成配置，而不是声明配置")]),i("h3",{attrs:{id:"base、client、server-三套配置"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#base、client、server-三套配置","aria-hidden":"true"}},[e._v("#")]),e._v(" base、client、server 三套配置")]),i("p",[e._v("和 Vue 的 SSR 三套配置对应")]),i("ul",[i("li",[e._v("基础配置\n"),i("ul",[i("li",[e._v("实例化一个 markdown，在 markdown-loader 的参数中传进去")]),i("li",[e._v("只在需要兼容浏览器时时添加 babel-loader")]),i("li",[e._v("为 rule 添加 postcss-loader，配置 autoprefixer 插件")]),i("li",[e._v("createCSSRule 批量应用样式加载规则\n"),i("ul",[i("li",[e._v("把关于 loader 的逻辑抽象到 applyLoaders(rule, modules) 里\n"),i("ul",[i("li",[e._v("为 css-loader 增加选项：是否模块化、生产环境压缩、打包文件名设置")])])])])]),i("li",[e._v("获取缓存目录和缓存标识在 cache-loader 和 vue-loader 选项中使用，封装在 applyVuePipeline(rule) 里\n"),i("ul",[i("li",[e._v("vue 和 markdown 规则都调用了 applyVuePipeline，markdown 规则额外使用 markdown-loader(./markdownLoader)，参数传 sourceDir, markdown")])])]),i("li",[e._v("使用 injections 注入常量开启 GA 和 Worker")])])]),i("li",[e._v("开发配置\n"),i("ul",[i("li",[e._v("模拟 node 变量")]),i("li",[e._v("针对服务端构建生成客户端 manifest 文件\n"),i("ul",[i("li",[e._v("添加 optimize-css-assets-webpack-plugin 插件，在选项里对 cssProcessorOptions 配置安全模式")])])])])]),i("li",[e._v("构建配置\n"),i("ul",[i("li",[e._v("针对 SSR 添加部分配置")]),i("li",[e._v("使用 copy-webpack-plugin 复制 .vuepress/public 下的资源文件")])])])]),i("h3",{attrs:{id:"编写-webpack-插件（打断点演示）"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#编写-webpack-插件（打断点演示）","aria-hidden":"true"}},[e._v("#")]),e._v(" 编写 webpack 插件（打断点演示）")]),i("p",[e._v("apply 里是插件逻辑")]),i("ul",[i("li",[e._v("markdownLoader.js 实现 md 转 vue\n"),i("ul",[i("li",[e._v("通过 getOptions 方法获取 markdown-it 实例")]),i("li",[e._v("新建 devCache，用于手动缓存链式加载器，用文件哈希值做键\n"),i("ul",[i("li",[e._v("使用 lru-cache 算法，当处于线上环境或者已有 vue 文件使用缓存")]),i("li",[e._v("允许 md-it 添加自定义插件，并在 render 函数中注册数据：先检查相对链接是否有效，再获取结果模板，加入缓存")])])]),i("li",[e._v("yaml front matter 也在此被转成 markdown\n"),i("ul",[i("li",[e._v("创建一个缓存哈希表用来 diff frontmatter 和 标题，如果有变化，触发更新事件")])])]),i("li",[e._v("生成 vue 的 html 代码\n"),i("ul",[i("li",[e._v("在模板里把要提升的标签也拼接进去，使用 hoist 插件产生的标签")])])]),i("li",[e._v("新导出一个 frontmatterEmitter 为一个事件触发器")])])]),i("li",[e._v("clientPlugin.js 用作客户端 ssr 渲染的插件 VueSSRClientPlugin\n"),i("ul",[i("li",[e._v("在 compiler 的钩子里触发 vue-client-plugin\n"),i("ul",[i("li",[e._v("获取 manifest 对象")]),i("li",[e._v("遍历 stats.modules，忽略多个块中的重复块，移除拓展的 hash，找到与同一块相关的所有资产模块")]),i("li",[e._v("最终定义 compilation 的 assets 数组内容，调用回调")])])])])]),i("li",[e._v("HeadPlugin.js，将传入的标签们生成 head 标签推入到 data 里")]),i("li",[e._v("DevLogPlugin.js\n"),i("ul",[i("li",[e._v("在 apply(compiler) 中设置 vuepress-log 钩子：先清屏，然后从 options 获取主机、端口、公共路径，提示相关构建信息。")])])])])])}],!1,null,null,null);l.default=r.exports}}]);